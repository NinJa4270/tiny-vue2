# 5.异步更新阶段是如何实现的？

1.  入口 `dep.notify` 通知依赖更新
2.  会遍历收集到的所有`watcher`的数组 执行每个`watcher`的`update`方法
3.  而`update`方法，又会走到``分支并执行`queueWatcher` 将`watcher`放入`watcher队列`
4.  `queueWatcher`的实现
    1.  获取传入的`watcher.id`
    2.  通过全局对象`has`判断`id`是否存在来判断当前传入的`watcher`是否重复
    3.  如果不存在 用全局对象`has`来保存当前传入的`id`为`true`,以便判断传入`watcher`是否重复
    4.  判断全局标识`flushing`
        1.  如果`flushing`为`false`，表示`watcher队列`没有被刷新
            1.  直接将`watcher`放入全局的`queue` `watcher队列`中
        2.  如果`flushing`为`true`，表示`watcher队列`正在被刷新
            1.  `watcher`插入到指定位置（`queue`按`watcher.id`从小到大排序）
            2.  特殊的插入规则：
                1.  `id`的值越大也就是越新的
                2.  新更新父组件，再更新子组件
                3.  先更新一个组件的`user watcher`，再更新`render watcher`
                4.  如果组件在父组件被更新的时销毁，则跳过这个组件
    5.  判断全局标识`waiting`
        1.  如果 `waiting` 为`false` 表示浏览器的异步任务队列中 没有 `flushSchedulerQueue`函数
        2.  则执行 `nextTick(flushSchedulerQueue)` `nextTick` 查看 **6** 查看 `flushSchedulerQueue` **7**
5.  `scheduler`文件下
    1.  全局对象`has`，用于存放`watcher.id` 作用是进行判重 重复的`watcher`不会入队
    2.  全局`queue`,用户存放入队的`watcher`
    3.  全局标识`flushing` 表示当前的`watcher队列`是否正在被刷新 默认`false`
    4.  全局标识`waiting` 用来表示浏览器的异步任务队列中 有没有存在 `flushSchedulerQueue` 函数 默认值为`false`
6.  `nextTick`的实现原理
7.  `flushSchedulerQueue`的实现原理